[{"title":"java编程思想读书笔记二","date":"2017-04-24T13:39:14.000Z","path":"2017/04/24/java编程思想读书笔记二/","text":"java对象对象的创建java的对象是在运行时创建的，创建对象的的触发条件有以下几种： 用new语句创建对象，这是最常用的创建对象方法。 运用反射手段，调用java.lang.reflect.Constructor类的newInstance()实例方法。 调用对象的clone()方法。 运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。 对象创建过程java对象在创建时需要在方法区的运行时常量池去查找该类的符号引用，如果没有发现符号引用，说明该类还没有被JVM加载，所以要先进行JVM的加载。当JVM加载完时，会在java堆中分配内存。分配内存时会根据堆内存是否规整来分别进行两种方式的分配。1.指针碰撞把内存分为可用的和已用的，在中间放置一个指针，如果要分配对象的空间，则把内存的指针向可用的一端移动当前需要分配对象大小的距离。2.空闲列表当内存并不是很规整时，需要一个列表来维护那些列表是可用的，那些是不可用的。 当内存分配完成后需要对分配到内存空间的对象赋予零值（静态字段在类加载中就已经有值，所以不需要赋零值），接下来需要设置对象头的信息：如设置该对象的哈希码，属于哪个类，GC分代年龄等信息。从虚拟机的角度来看至此一个对象就创建完成，但是在java程序的角度看，对象的创建才刚刚开始，因为对象的值还没有设定，对象值得设定是由对象初始化化来完成的，初始化就是调用构造方法过程。 对象的初始化当对象创建完成后，接下来就是进行对象的初始化了，也就是去执行构造方法。 父类的初始化当子类对象创建之前首先会调用父类的构造函数，也就是会初始化父类，但是父类并没有被创建，也就是并没有在堆中给父类分配新的存储空间，而只是对父类的变量进行了赋值。从而达到子类可以使用父类的属性和方法的目的。 静态类的初始化当一个类中有static修饰的方法或者是变量的话，那么当这个静态方法被第一次调用的时候，那么这个类就会初始化，就会调用此类的类构造器(在类加载过程中被JVM自动加入)，类构造器只初始化一次，触发条件为实例构造器执行，或者是静态任何一个静态成员被引用，也就是说这个类只会初始化一次。 普通类的初始化区别与父类和静态类的初始化，普通类的初始化是建立在对象创建之上的，也就是对象创建完成后会自动的去调用构造方法进行初始化。 对象创建及初始化实例看完上面文字上的简单说明总感觉少些什么东西？就像一碗牛肉拉面没有卤鸡蛋一样。所以笔者要通过一个java代码来将上面的知识点串起来，让你有一个更清晰的认识。 12345678910111213141516171819202122232425262728293031323334353637public class Parent &#123; int a = 1; static int b = 2; // 静态代码块 static &#123; System.out.println(\"执行Parent静态代码块：b =\" + b); b++; &#125; // 普通代码块 &#123; System.out.println(\"执行Parent普通代码块： a =\" + a); System.out.println(\"执行Parent普通代码块： b =\" + b); b++; a++; &#125; // 无参构造函数 Parent() &#123; System.out.println(\"执行Parent无参构造函数： a =\" + a); System.out.println(\"执行Parent无参构造函数： b =\" + b); &#125; // 有参构造函数 Parent(int a) &#123; System.out.println(\"执行Parent有参构造函数： a =\" + a); System.out.println(\"执行Parent有参构造函数： b =\" + b); &#125; // 方法 void fun() &#123; System.out.println(\"执行Parent的fun方法\"); &#125;&#125; 1234567891011121314151617181920212223242526272829public class Child extends Parent &#123; int c = 1; static int d = 2; // 静态代码块 static &#123; System.out.println(\"执行Child静态代码块：d =\" + d); d++; &#125; // 普通代码块 &#123; System.out.println(\"执行Child代码块： c =\" + c); System.out.println(\"执行Child代码块： d =\" + d); c++; d++; &#125; // 构造函数 Child() &#123; System.out.println(\"执行Child构造函数： c =\" + c); System.out.println(\"执行Child构造函数： d =\" + d); &#125; // 方法 void fun() &#123; System.out.println(\"执行Child的fun方法\"); &#125;&#125; 12345678910public class Test &#123; public static void main(String[] args) &#123; Child demo = new Child(); demo.fun(); System.out.println(\"…………………………………………………………………………………………………………………………\"); Child child = new Child(); child.fun(); &#125;&#125; 上面有三个很简单的类，一个Parent,一个Child,一个Test。当执行Test的main方法是会输出什么呢？ 12345678910111213141516171819202122//输出结果执行Parent静态代码块：b =2执行Child静态代码块：d =2执行Parent普通代码块： a =1执行Parent普通代码块： b =3执行Parent无参构造函数： a =2执行Parent无参构造函数： b =4执行Child代码块： c =1执行Child代码块： d =3执行Child构造函数： c =2执行Child构造函数： d =4执行Child的fun方法…………………………………………………………………………………………………………………………执行Parent普通代码块： a =1执行Parent普通代码块： b =4执行Parent无参构造函数： a =2执行Parent无参构造函数： b =5执行Child代码块： c =1执行Child代码块： d =4执行Child构造函数： c =2执行Child构造函数： d =5执行Child的fun方法 下面我们一起来看看这些输出是这么一步步产生的。 注：本文的重点不是虚拟机有关的详细执行，之后会专门写一个关于虚拟机加载的文章，所以有关细节问题都一笔带过了","tags":[{"name":"java","slug":"java","permalink":"http://anning1994.coding.me/tags/java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://anning1994.coding.me/tags/读书笔记/"}]},{"title":"java编程思想读书笔记一","date":"2017-04-16T08:34:32.000Z","path":"2017/04/16/java编程思想读书笔记一/","text":"面向对象我们常见的编程范式有命令式编程，函数式编程，逻辑式编程，面向对象编程是一种命令式编程。 命令式编程式面向计算机硬件的一种抽象，有变量（存储单元），赋值语句（获取存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令），命令式程序就是对一个冯诺依曼机的指令序列的抽象，面向对象是对我们现实世界模型的一个抽象，之后在映射到冯诺依曼机的指令序列。 面向对象的基本特性如果只是用变量，赋值语句，表达式，控制语句去构建现实世界模型的话会非常困难，所以面向对象的出现的根本原因就是就是为了解决这个问题。 面向对象让我们从指令代码操作变量转变为通过指令操作对象。 当我们理解了这个以后再去看面向对象的基本特征： 抽象封装 首先抽象就是建立一个对现实模型的抽象，封装就是将变量，赋值语句，表达式，控制语句进行组合来描述上面的抽象，并且将他们“打包”，看成一个原子结构，之后的程序逻辑都是围绕着这个原子结构进行的。 最后，面向对象的编程就是将原来的 ”模式一“ 改变为 ”模式二” 模式一：程序 = （赋值语句+表达式+控制语句）+ 变量 模式二：程序 = 对象 + 对象（对象之间的调用） 面向对象的高级特性对象之间的关联关系抽象，封装只是对现实模型和冯诺依曼机之间基本的映射关系，而现实世界中模型与模型之间还存在很多关系，如继承、组合、依赖等。 而维护这些关系也成为面向对象语言的一个特性，并且有相应的语法支持。 1.继承is-a组合：一个类继承具有相似功能的另一个类，根据需要在所继承的类基础上进行扩展。优点： 具有共同属性和方法的类可以将共享信息抽象到父类中，增强代码复用性，同时也是多态的基础。缺点： 子类中扩展的部分对父类不可见，另外如果共性比较少的时候使用继承会增加冗余代码。 2.组合has-a组合：has-a组合是在一个类中引用另一个类作为其成员变量。优点： 可扩展性和灵活性高。在对象组合关系中应优先考虑has-a组合关系。缺点： 具有共性的类之间看不到派生关系。 多态多态在代码复用中起着尤为重要的作用，假如对象A依赖对象B，如果有对象C继承对象B，则说明对象C包含对象B,所以当对象C向上转型为对象B时不会出现信息的丢失，大部分静态编程语言都支持向上转型。所以对象A对B的操作完全适用于C，所以当依赖B和依赖C时会有不同的表现，并且这个判断过程实在运行期决定的。 1234567891011121314151617181920212223242526272829303132public class A &#123; public void fun(B b)&#123; b.fun(); &#125;&#125;public class B &#123; public void fun()&#123; System.out.println(\"我是b\"); &#125;&#125;public class C extends B&#123; //重载 public void fun()&#123; System.out.println(\"我是c\"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; A a = new A(); B b = new B(); C c = new C(); a.fun ( b ); a.fun ( c ); &#125;&#125;-------------------------------------------------Output:我是b我是c 以上是最简单的多态的例子，通过上面例子很难发现多态的好处，这样做的意义是什么？ 观察上面的代码会发现，A的fun（）方法参数为B，但是如果传递别的类型可不可以？答案是可以的，因为上面的代码中我们传递了B的子类C，如果有D、E、F….都继承B的话，也都可以传递到A的fun()中，所以起到了复用的作用。 但是还是体现不出来多态的好处，传递必须要继承这个类，不符合现实模型，比如A是播放叫声的装置，B是斑点狗，所以将B传递进去时会播放斑点狗的叫声，而C要是继承B,在现实生活世界模型中，C也是斑点狗才行。 那如果我想播放牧羊犬的叫声怎么办？用抽象类就可以。如果B是抽象类的话，抽象的是狗，所以C可以任何狗，因为B中的所有东西都是抽象的，没有任何描述狗细节的东西，所以可以是任何狗。 最后还是发现不完善，那如果我要播放猫叫声怎么办？这时候会有个比抽象类还抽象的东西，那就是接口，一个超级有用的家伙，有了他就可以完全和现实世界模型对应起来了，因为接口抽象的是行为，所以当B为接口时，规定B有叫声方法，所以当A的fun方法中传递的B接口时，就可以理解为，只要传递实现叫声方法的就可以，无论什么。所以当猫实现这个接口后，就可以被放到声音播放器当中，同样马、猪、牛都可以，只要他们实现叫声接口就行，但是树可以吧？不可以，因为现实世界中的树不可以叫。所以接口只抽象行为，完全可以实现现实模型的和面向对象的映射。 所以抽象程度从小到大分别为类&gt;抽象类&gt;接口。 当B为类时，A只能接收B子类。 当B为抽象类时，A能接收符合这个抽象的具体。 当B为接口时，A能接收实现B接口的任何东西，在当前上下文中就是有叫声的任何东西。 所以当B为普通类时，A就是一个 斑点狗叫声播放器。当B为抽象类时，A就为一个 狗的叫声播放器。而当B为接口时，A就是一个 叫声播放器，可以播放任何声音，这就是多态的意义。 一个斑点狗播放器和一个可以播放任何声音的播放器不存在那个更好，要根据实际的场景进行判断，一个作用域小一个作用域大。 其实在框架中或者“造轮子的人”用接口的比较多，而“用轮子的人”用普通类比较多，所以当阅读源码发现各种接口时不要疑惑，那是多数是为了让代码通用、作用域大。","tags":[{"name":"java","slug":"java","permalink":"http://anning1994.coding.me/tags/java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://anning1994.coding.me/tags/读书笔记/"}]},{"title":"代码界的石器时代（转载）","date":"2017-03-17T09:20:00.000Z","path":"2017/03/17/代码界的石器时代/","text":"原文链接： https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn 公园漫步时间机器启动……我们来到公元前380年，也就是2000多年前的雅典城外。这是一个阳光明媚的久违的春天，柏拉图和一个帅气的小男仆走在一片橄榄树荫下。他们正准备前往一个学院。天气很好，吃得很饱，渐渐的，两人的谈话转向了哲学。 “你看那两个学生，哪一个更高一些？”，柏拉图小心的选择用字，以便让这个问题更好的引导眼前的这个小男孩。小男仆望向水池旁边的两个男生，“他们差不多一样高。”。“差不多一样高是什么意思？”柏拉图问。“嗯……从这里看来他们是一样高的，但是如果走近一点我肯定能看出差别来。”柏拉图笑了。他知道这个小孩已经朝他引导的方向走了。“这么说来你的意思是世界上没有什么东西是完全相同的咯？”思考了一会，小男孩回答：“是的。万物之间都至少有一丁点差别，哪怕我们无法分辨出来。”说到点子上了！“那你说，如果世界上没有什么东西是完全相等的，你怎么理解完全相等这个概念？”小男仆看起来很困惑。“这我就不知道了。” 这是人类第一次试图了解数学的本质。柏拉图认为我们所在的世界中，万事万物都是完美模型的一个近似。他同时意识到虽然我们不能感受到完美的模型，但这丝毫不会阻止我们了解完美模型的概念。柏拉图进而得出结论：完美的数学模型只存在于另外一个世界，而因为某种原因我们却可以通过联系着这两个世界的一个纽带来认识这些模型。一个简单的例子就是完美的圆形。没有人见过这样的一个圆，但是我们知道怎样的圆是完美的圆，而且可以用公式把它描述出来。 如此说来，什么是数学呢？为什么可以用数学法则来描述我们的这个宇宙？我们所处的这个世界中万事万物都可以用数学来描述吗？数理哲学是一门很复杂的学科。它和其他多数哲学一样，更着重于提出问题而不是给出答案。数学就像拼图一样，很多结论都是这样推导出来的：先是确立一些互不冲突的基础原理，以及一些操作这些原理的规则，然后就可以把这些原理以及规则拼凑起来形成新的更加复杂的规则或是定理了。数学家把这种方法称为“形式系统”或是“演算”。如果你想做的话，可以用形式系统描述俄罗斯方块这个游戏。而事实上，俄罗斯方块这个游戏的实现，只要它正确运行，就是一个形式系统。只不过它以一种不常见的形式表现出来罢了。 如果半人马阿尔法上有文明存在的话，那里的生物可能无法解读我们的俄罗斯方块形式系统甚至是简单的圆形的形式系统，因为它们感知世界的唯一器官可能只有鼻子，也许它们是无法得知俄罗斯方块的形式系统了，但是它们很有可能知道圆形。它们的圆形我们可能没法解读，因为我们的鼻子没有它们那么灵敏，可是只要越过形式系统的表示方式（比如通过使用“超级鼻子”之类的工具来感知这些用味道表示的形式系统，然后使用标准的解码技术把它们翻译成人类能理解的语言），那么任何有足够智力的文明都可以理解这些形式系统的本质。有意思的是，哪怕宇宙中完全不存在任何文明，类似俄罗斯方块还有圆形这样的形式系统依旧是成立的：只不过没有智慧生物去发现它们而已。这个时候如果忽然一个文明诞生了，那么这些具有智慧的生物就很有可能发现各种各样的形式系统，并且用它们发现的系统去描述各种宇宙法则。不过它们可能不会发现俄罗斯方块这样的形式系统，因为在它们的世界里没有俄罗斯方块这种东西嘛。有很多像俄罗斯方块这样的形式系统是与客观世界无关的，比如说自然数，很难说所有的自然数都与客观世界有关，随便举一个超级大的数，这个数可能就和世界上任何事物无关，因为这个世界可能不是无穷大的。 历史回眸再次启动时间机……这次到达的是20世纪30年代，离今天近了很多。无论新旧大陆，经济大萧条都造成了巨大的破坏。社会各阶层几乎每一个家庭都深受其害。只有极其少数的几个地方能让人们免于遭受穷困之苦。几乎没有人能够幸运的在这些避难所里度过危机，注意，我说的是几乎没有，还真的有这么些幸运儿，比如说当时普林斯顿大学的数学家们。 新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。 一个名叫阿隆佐·邱奇(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有艾伦·图灵、约翰·冯·诺伊曼、库尔特·哥德尔。这四个人都对形式系统感兴趣。相对于现实世界，他们更关心如何解决抽象的数学问题。而他们的问题都有这么一个共同点：都在尝试解答关于计算的问题。诸如：如果有一台拥有无穷计算能力的超级机器，可以用来解决什么问题？它可以自动的解决这些问题吗？是不是还是有些问题解决不了，如果有的话，是为什么？如果这样的机器采用不同的设计，它们的计算能力相同吗？在与这些人的合作下，阿隆佐设计了一个名为lambda演算的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。这种函数用希腊字母lambda（λ），这种系统因此得名4。有了这种形式系统，阿隆佐终于可以分析前面的那些问题并且能够给出答案了。除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。 如果二战没有发生，这个故事到这里就应该结束了，我的这篇小文没什么好说的了，你们也可以去看看有什么其他好看的文章。可是二战还是爆发了，整个世界陷于火海之中。那时的美军空前的大量使用炮兵。为了提高轰炸的精度，军方聘请了大批数学家夜以继日的求解各种差分方程用于计算各种火炮发射数据表。后来他们发现单纯手工计算这些方程太耗时了，为了解决这个问题，各种各样的计算设备应运而生。IBM制造的Mark一号就是用来计算这些发射数据表的第一台机器。Mark一号重5吨，由75万个零部件构成，每一秒可以完成3次运算。战后，人们为提高计算能力而做出的努力并没有停止。1949年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是冯·诺伊曼设计架构的第一个实例，也是一台现实世界中实现的图灵机。相比他的这些同事，那个时候阿隆佐的运气就没那么好了。到了50年代末，一个叫John McCarthy的MIT教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！很多计算机科学家都认识到了Lisp强大的能力。1973年在MIT人工智能实验室的一些程序员研发出一种机器，并把它叫做Lisp机。于是阿隆佐的lambda演算也有自己的硬件实现了！","tags":[{"name":"宏观编程","slug":"宏观编程","permalink":"http://anning1994.coding.me/tags/宏观编程/"}]},{"title":"Apache VFS","date":"2017-03-16T14:20:02.000Z","path":"2017/03/16/Apache-VFS/","text":"Apache VFS简要介绍VFS （虚拟文件系统），可以通过程序 去操作文件系统，这里说的文件系统是一个泛称，不同的文件系统有着不同的操作权限，它具体包括下表的几种文件系统（红色标记的是我们之后可能会用到的文件系统）: Name Authentication Read Write Create/Delete Random Version Rename FILE NO Yes Yes Yes Read/Write NO Yes FTP Yes Yes Yes Yes Read NO Yes HTTP Yes Yes NO NO Read NO NO BZIP2 NO Yes Yes NO NO NO NO FTPS Yes Yes Yes Yes Read NO Yes GZIP NO Yes Yes NO NO NO NO HDFS NO Yes NO NO Read NO NO HTTPS Yes Yes NO NO Read NO NO Jar NO Yes NO NO NO NO NO RAM NO Yes Yes Yes Read/Write NO Yes RES NO Yes Yes Yes Read/Write NO Yes SFTP Yes Yes Yes Yes Read NO Yes Tar NO Yes NO NO NO NO NO Temp NO Yes Yes Yes Read/Write NO Yes WebDAV Yes Yes Yes Yes Read/Write Yes Yes Zip NO Yes NO NO NO NO NO VFS使得各种不同的文件系统使用一个API。例如本地磁盘上的文件，HTTP服务器上的文件或Zip存档内的文件。 开始使用依赖1234567&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-vfs2 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-vfs2&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; 核心API1.FileSystemManager管理文件系统的接口，是最上层的接口，必须先得到FileSystemManager，可以获得具体的FileObjectFileObject在下面会有介绍。获取FileSystemManager最常用的方式就是：12FileSystemManager fsm = VFS.getManager(); 2.FileObject它代表一个文件，和Java File不同，它具有更多延伸的功能和信息。实现FileObject接口的文件对象有很多大部分FileObject实现类都继承AbstractFileObject类,如下是常用的实现类: LocalFile FtpFileObject HttpFileObject SftpFileObject ZipFileObject TarFileObject RamFileObject UrlFileObject 12345 /** * @param path * @return */FileObject fileobject = fsm.resolveFile(path); path是文件的路径，不同的文件系统有不同的前缀 File [file://] absolute-path Examples: file:///home/someuser/somedirfile:///C:/Documents and Settingsfile://///somehost/someshare/afile.txt/home/someuser/somedirc:\\program files\\some dirc:/program files/some dir Ftp ftp://[ username[: password]@] hostname[: port][ relative-path] Examples: ftp://lxsoft:123456@127.0.0.1/pub/downloads/somefile.tgz Http http://[ username[: password]@] hostname[: port][ absolute-path] Examples: http://127.0.0.1:8080/downloads/somefile.jarhttp://username@127.0.0.1/index.html FileObject表示一个具体文件，文件有两种类型： 目录 普通文件 普通文件拥有数据或者说内容。而目录不含有内容，只能包含其他文件。 FileObject提供大量的方法，足以满足读取，删除，复制，重命名等基本操作。 FileObject接口的API 高级特性及demo文件的监听FileListener 有两个实现类DelegateFileObject和WeakRefFileListener，时间有限没有研究这两个实现类是干什么的，有兴趣的同学可以研究一下，但是这个监听类是可以绑定到文件系统上面的。 12345678910111213141516171819202122232425262728293031FileSystemManager fsm = VFS.getManager();FileObject fileObject = fsm.resolveFile(path);//在文件系统中添加监听器（lambda和匿名内部类都会方便点，也可以直接new个对象传到addListener方法中）fileObject.getFileSystem().addListener(fileObject,new FileListener() &#123; @Override public void fileCreated(FileChangeEvent fileChangeEvent) throws Exception &#123; String name = fileChangeEvent.getFile().getName().getBaseName(); System.out.print(\"文件创建了\"+name); &#125; @Override public void fileDeleted(FileChangeEvent fileChangeEvent) throws Exception &#123; String name = fileChangeEvent.getFile().getName().getBaseName(); System.out.print(\"文件删除了\"+name); &#125; @Override public void fileChanged(FileChangeEvent fileChangeEvent) throws Exception &#123; String name = fileChangeEvent.getFile().getName().getBaseName(); System.out.print(\"文件更改了\"+name); &#125; &#125;); if (fileObject.exists())&#123; //删除path对应的文件或者目录 //fileObject.delete() &#125;else&#123; //创建一个文件 fileObject.createFile(); //或者创建文件夹 //fileObject.createFolder() &#125; 文件过滤通过看API试出来的方法，这方面网上的资料太少了，只有以后遇到什么需求在查看API去解决。123456789101112131415161718192021FileSystemManager fsm = VFS.getManager();FileObject fileObject = fsm.resolveFile(path);//lambda表达式更加直观方便FileSelector selector = new FileFilterSelector((fileSelectInfo)-&gt;&#123; boolean isCSV = fileSelectInfo.getFile().getName().getBaseName().endsWith(\".txt\"); return isCSV; &#125;);//匿名内部类，效果等同于上面的lambda// FileSelector selector = new FileFilterSelector(new FileFilter() &#123;// @Override// public boolean accept(FileSelectInfo fileSelectInfo) &#123;// boolean isCSV = fileSelectInfo.getFile().getName().getBaseName().endsWith(\".txt\");// return isCSV;// &#125;// &#125;); FileObject[] findFiles = fileObject.findFiles(selector); for (int i = 0; i &lt; findFiles.length; i++) &#123; String name = findFiles[i].getName().getBaseName(); System.out.print(name); &#125; &#125; 这段代码的作用就是过滤出在path下*.txt的所有文件","tags":[{"name":"编程规范","slug":"编程规范","permalink":"http://anning1994.coding.me/tags/编程规范/"}]},{"title":"关于写博客的一点小想法","date":"2017-03-15T14:04:04.000Z","path":"2017/03/15/关于写博客的一点小想法/","text":"千里之行，始于足下越来越发现，一件复杂的事情只要满足两个条件就可以做好，一是坚持不懈、二是有个开始。 很早以前就有写博客的想法，直到现在才正式动笔，中间很长一段时间都是在想这件事是如何的复杂，如何困难。直到意识到工作中遇到的一些很难的事，都通过一点一点的努力完成了。回头想想自己之前认为困难的事，难都难在不敢去开始，如果真的开始去解决那些事，也许自己会收获很多。这些新的思想觉悟便是促使自己搭建这个博客的重要条件。 思所以危则安矣避免技术更新导致自我价值降低很重要。 软件研发技术迭代很快，是一个没有技术积累的行业。所以思维方式，学习方法，核心概念的理解，远远比那些机械的记忆程序的配置，单纯的参考网上的例子实现功能要重要的多。如果仅仅是代码的搬运工，极可能被技术更新的大浪所埋没。所以，透彻的理解技术映射出的本质思想的标签是每一个“优质码农”都具备，看过很多阿里的技术沙龙，每一个主讲人的特点都是去解释思想，本质。而那些技术的用法都是一概而过。抛开技术而言，这些人在分享过程中也是很有特点的： 条理清晰 思维缜密 谦逊客观表达能力较差ppt简约技术横纵双向发展善于分析新旧技术的核心区别 这些天赋异禀的人的特点，看起来就像”成功的**所必备的n个**”的俗鸡汤，但是，不开玩笑的讲，除了表达能力差，这些特点确实是很值得去借鉴和培养的。 厚积而薄发其实自己搭建博客主要是因为可以装逼自主方便，其目的是整理一些印象笔记里平时记录的东西。 一方面秉承互联网大环境分享精神的大统，另一方面可以在写的过程中可以系统的完善自己的知识体系。在学习新知识的同时也要时不时的回头去沉淀一下自己的旧知识。 我相信收获一定会有的，一直往前走，它会突然出现在未来的某一天，共勉。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://anning1994.coding.me/tags/随笔/"}]}]