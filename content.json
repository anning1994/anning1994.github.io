[{"title":"补码","date":"2018-07-29T08:14:19.000Z","path":"2018/07/29/补码/","text":"基本概念在计算机中，二进制数据有三种形式：原码、反码和补码，要弄清楚补码的意义，首先让我们来了解三种形式的定义。 假设字长为4，其中最高位为符号位：正数为0，负数为1。剩下的3位表示该数的绝对值。正数的原码反码补码都是一样的。 1.原码 +3的原码：0011 -3的原码：1011 2.反码 反码就是在原码的基础上，符号位不变其他位按位取反(就是0变1，1变0)就可以了。 +3的反码：0011 -3的反码：1100 3.补码 补码也非常的简单，就是在反码的基础上按照正常的加法运算加1。 +3的补码：0011 -3的补码：1101 从前面的三种数字编码类型的定义，我们可以看出数据的原码，使用符号位来区分了正负数，更加符合人脑直观识别并且用于计算的表达方式。但是在计算机中，是通过补码的形式保存数据，下面将解释为什么计算机系统要用补码存放数据。 周期系统 若一组事件或现象按同样的顺序重复出现，则把完成这一组事件或现象的时间或空间间隔，称为周期。 周期性原码累加系统定义一个字长为4的二进制累加系统，该系统的规则就是从左到右依次累加0001； 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 0000 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 如果最高位是符号位时，图表第二行表示原码对应的10进制数，不难发现，如果在确定字长为4时，累加过程是符合周期性变化的，原因就是当1111+1时会出现字节溢出的情况，10000的最高位溢出失效，导致结果变为0000； 周期性时钟系统 在现实生活中，时钟显然是符合周期性的，12点过后是1点，人们早已习惯了这种思维方式，所以会忽略对时钟这种表示时间方式的思考。凌晨12点加1个小时，其实表式的时间是天数加1之后的1点，但是对于时钟系统而言，天数不是自己所能表示的，这就相当于上面图表中1111+1=0000(1|0000 1是溢出位，在字长为4的系统中是不能表示的)。 时钟系统和二进制数原码的累加系统都有周期性，具有周期性的原因是当前层次系统中有其不能表示或未能感知的其他层次系统。 计算机运算系统正是利用了周期性的这一特性。 周期系统中的加减转化时钟系统加减法转化假设时针向顺时针方向拨动为加，逆时针拨动为减。 7点顺时针拨动1格表示的是：7+1=8 7点逆时针拨动1格表示的是：7-1=6 7点顺时针拨动11格表示的是：7+11=6 所以很容易发现，在时钟中7-1=7+11，这就是周期系统中加减法发的转化方式，其实和简单，也很符合我们的直觉。 所以重新考虑原码的减法问题，n-m = n+(MAX-m),其中MAX就是该周期中所能表示的所有数的数量，放到上面原码的例子中就是16个，而放到时钟系统中就是12个。如： 周期性的时钟系统: 12 - 1 = 12 + （12 -1）； 7 - 4 = 7 +（12-4）； 累加系统加减法转化在说原码累加系统加减法转化例子之前，我们再看下图表 A 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 0000 A1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 A2 0 1 2 3 4 5 6 7 -0 -1 -2 -3 -4 -5 -6 -7 0 B 0000 0001 0010 0011 0100 0101 0110 0111 1111 1110 1101 1100 1011 1010 1001 1000 0000 B1 0 1 2 3 4 5 6 7 -7 -6 -5 -4 -3 -2 -1 -0 0 B2 0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1 0 为了方便说明在每一行的开始定义了该行的名称分别为A、A1、A2、B、B1、B2. 累加系统不同于周期系统的一点是会有负数的概念出现，C行就是最高位表示符号位时原码解码后表示的十进制数。在图表中发现，当有符号位时二进制原码的累加转换为十进制数时，出现了与我们现实生活数学公理相违背的现象，错误发生在最高位为1后，如1001+1=1010(-1+1=-2)，原因是在定义这个累加系统在运算时就没有让系统知道高位0与1有不同之处，也就是累加的计算过程中无法感知符号。 解决问题的方式有两种 去重新完善这个累加系统，让他在最高位为1换一套计算方式，也就是说在运算过程中去感知最高位的意义。 转化出现问题的状态，使状态转移为当前系统能使用的，也就是在编码过程中去让无法感知符号的运算系统计算出正确的结果。 在计算机系统中，解决这个问题的方式显然是用第二种，cpu是无法感知符号位的，这样做可以减少cpu设计难度，极大地提高运行效率。所以也就是说cpu运算时还是按照A行进行累加，但在解码运算结果时做一些处理，即将A转变为B，而B1是不考虑溢出和临界值时的十进制正确结果。A解码为B的算法就是当最高位为1时，符号位不变，其他位取反，不难发现这就是反码的定义。 当这样转化后会发现出现了0和-0两个0并且会出现0 - 1 = -0这种情况(将0向左移动)。所以还得做一个简单的处理，就是去加一个1，也就是B1转化为B2,而B2就是最终的正确十进制值。 其实按照直觉可以发现，当符号位转化时，其他位应该取反才能得到正确结果，正数越加越大，负数越加越小。 根据我们的努力将A通过反码的解码方式转变为B,而让B的解码结果加1(补码)，得到了B2,从而使累加系统当出现负数时变得合理起来。在转变为B2之后，我们需要解决的是如何用累加系统去表示减法。本质上和前面的时钟系统转化是一样的。可以借助上面的时钟系统以及下面的例子去理解累加系统的减法运算。 在看例子之前，稍微介绍一下“模” 的概念:模是指一个计量系统的计数范围，取模运算实质上是计量器产生“溢出”的量，前面的周期系统中n-m = n+(MAX-m)得出的加减转化其实就是用到了模的概念，MAX就是模。 计算 4 - 3 编码 0100 - 0011 //n-m = n+(MAX-m) ==》(10000-0011) 其结果就是0011的补码 转化为 0100 + (10000-0011) = 0100 + 1101 cpu调用加法器得出 10001 最高位溢出 0001 解码 1 重新计算 3 - 4 编码 0011 - 0100 转化为 0011 + (10000-0100) = 0011 + 1100 cpu调用加法器得出 1111 //参考A转变B2(也就是原码转补码) 解码-0001= -1 总结在计算机系统中，计算整数加减法时，需要经过以下步骤： 转变为2进制数； 运算时原码解码为补码；n-m = n+(MAX-m)，(MAX-m)也就是m的补码，理解时参考时钟系统。 cpu调用加法器； 解码；再进行一次补码解码，理解时参考A转化为B2。","tags":[{"name":"计算机原理","slug":"计算机原理","permalink":"http://anning1994.github.io/tags/计算机原理/"}]},{"title":"2017我的书单","date":"2018-01-07T02:12:44.000Z","path":"2018/01/07/2017我的书单/","text":"计算机相关 java编程思想（★★★★★☆） 笔者对该书籍的定位就是宏观、全面、权威的java基础知识索引。书如其名，思想即为道，而语法则为术，道为正，术为正，则事半功倍。阅读此书也应该本着悟道而非学术为原则，宏观的去了解具有java特色的面向编程道路。非常不推荐利用该书去学习java基础，应当在对java有一定了解，并对面向编程思想有一定认知之后再来读它。读书获取知识的过程就是一种思想碰撞过程，你首先对书中所讲的内容有自己浅薄的一层认识，而在读的过程中来否定或者肯定你的认知，并要分析你的认知与作者的认知存在不同的原因是那些认知不同造成的？从而会产生出新的浅薄的认知，之后不断的在阅读中重复着这种过程，此为学习思想。 深入理解java虚拟机（★★★★★） 笔者认为编程也遵守巴莱多定律(28定律)，利用20%所学的东西就能解决你在工作中遇到的80%的问题，所以笔者推荐阅读本书，去掌握解决另外20%问题的技能。在网络上但凡涉及到虚拟机、java虚拟机内存划分、jvm内存模型、class文件加载、class文件解析、垃圾回收等博文，有80%都引用本书。所以笔者才找到此书，并在阅读过程中收获颇丰，系统性的认识了java虚拟机的相关知识。 3.","tags":[{"name":"资源分享","slug":"资源分享","permalink":"http://anning1994.github.io/tags/资源分享/"}]},{"title":"java基础3--HashMap","date":"2017-08-16T14:51:05.000Z","path":"2017/08/16/java基础3--HashMap/","text":"MapMap接口规定了一系列的操作，作为一个总规范它所定义的方法也是最基础，最通用的。笔者在下文所引用的源码都是基于java 1.8，在Java 1.8中，添加了default来修饰接口的方法，default的出现是为了优化接口的同时，避免跟之前实现架构产生兼容问题（背着沉重历史包袱前进），有兴趣的同学可以查下，这里就不展开说了。 AbstractMapAbstractMap是HashMap, TreeMap, ConcurrentHashMap 等类的父类。当我们宏观去理解Map时会发现，其实Map就是一个保存Entry的数组，AbstractMap类的设计就是用代码来描述这句话。 AbstractMap的设计思路是将方法的实现都建立在操作Entry数组上，从而将对Map所有方法的抽象转变为粒度更小的Entry数组对象的抽象，从而不同的Map实现类只需要简单的继承AbstractMap，并且实现entrySet()方法去构造Entry数组，便可以实现一个最简单的Map了。 12//AbstractMap中唯一的抽象方法public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet(); 当通过实现entrySet()方法后，构造出自己的Set","tags":[{"name":"java","slug":"java","permalink":"http://anning1994.github.io/tags/java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://anning1994.github.io/tags/读书笔记/"}]},{"title":"java基础2--对象的创建","date":"2017-04-24T13:39:14.000Z","path":"2017/04/24/java基础2--对象的创建/","text":"对象的创建详解对象的创建java的对象是在运行时创建的，创建对象的的触发条件有以下几种： 用new语句创建对象，这是最常用的创建对象方法。 运用反射手段，调用java.lang.reflect.Constructor类的newInstance()实例方法。 调用对象的clone()方法。 运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。 对象创建过程java对象在创建时需要在方法区的运行时常量池去查找该类的符号引用，如果没有发现符号引用，说明该类还没有被JVM加载，所以要先进行JVM的加载。当JVM加载完时，会在java堆中分配内存。分配内存时会根据堆内存是否规整来分别进行两种方式的分配。 1.指针碰撞把内存分为可用的和已用的，在中间放置一个指针，如果要分配对象的空间，则把内存的指针向可用的一端移动当前需要分配对象大小的距离。 2.空闲列表当内存并不是很规整时，需要一个列表来维护那些地址是可用的，那些是不可用的。 当内存分配完成后需要对分配到内存空间的对象赋予零值（静态字段在类加载中就已经有值，所以不需要赋零值），接下来需要设置对象头的信息：如设置该对象的哈希码，属于哪个类，GC分代年龄等信息。从虚拟机的角度来看至此一个对象就创建完成，但是在java程序的角度看，对象的创建才刚刚开始，因为对象的值还没有设定，对象值得设定是由对象初始化来完成的，初始化就是调用构造方法过程。 对象的初始化当对象创建完成后，接下来就是进行对象的初始化了，也就是去执行构造方法。 父类的初始化当子类对象创建之前首先会调用父类的构造函数，也就是会初始化父类，但是父类并没有被创建，也就是并没有在堆中给父类分配新的存储空间，而只是对父类的变量进行了赋值。从而达到子类可以使用父类的属性和方法的目的。 静态类的初始化当一个类中有static修饰的方法或者是变量的话，那么当这个静态方法被第一次调用的时候，那么这个类就会初始化，就会调用此类的类构造器(在类加载过程中被JVM自动加入)，类构造器只初始化一次，触发条件为实例构造器执行，或者是静态任何一个静态成员被引用，也就是说这个类只会初始化一次。 普通类的初始化区别与父类和静态类的初始化，普通类的初始化是建立在对象创建之上的，也就是对象创建完成后会自动的去调用构造方法进行初始化。 对象创建及初始化实例看完上面文字上的简单说明总感觉少些什么东西？就像一碗牛肉拉面没有卤鸡蛋一样。所以笔者要通过一个java代码来将上面的知识点串起来，让你有一个更清晰的认识。 12345678910111213141516171819202122232425262728293031323334353637public class Parent &#123; int a = 1; static int b = 2; // 静态代码块 static &#123; System.out.println(\"执行Parent静态代码块：b =\" + b); b++; &#125; // 普通代码块 &#123; System.out.println(\"执行Parent普通代码块： a =\" + a); System.out.println(\"执行Parent普通代码块： b =\" + b); b++; a++; &#125; // 无参构造函数 Parent() &#123; System.out.println(\"执行Parent无参构造函数： a =\" + a); System.out.println(\"执行Parent无参构造函数： b =\" + b); &#125; // 有参构造函数 Parent(int a) &#123; System.out.println(\"执行Parent有参构造函数： a =\" + a); System.out.println(\"执行Parent有参构造函数： b =\" + b); &#125; // 方法 void fun() &#123; System.out.println(\"执行Parent的fun方法\"); &#125;&#125; 1234567891011121314151617181920212223242526272829public class Child extends Parent &#123; int c = 1; static int d = 2; // 静态代码块 static &#123; System.out.println(\"执行Child静态代码块：d =\" + d); d++; &#125; // 普通代码块 &#123; System.out.println(\"执行Child代码块： c =\" + c); System.out.println(\"执行Child代码块： d =\" + d); c++; d++; &#125; // 构造函数 Child() &#123; System.out.println(\"执行Child构造函数： c =\" + c); System.out.println(\"执行Child构造函数： d =\" + d); &#125; // 方法 void fun() &#123; System.out.println(\"执行Child的fun方法\"); &#125;&#125; 12345678910public class Test &#123; public static void main(String[] args) &#123; Child demo = new Child(); demo.fun(); System.out.println(\"…………………………………………………………………………………………………………………………\"); Child child = new Child(); child.fun(); &#125;&#125; 上面有三个很简单的类，一个Parent,一个Child,一个Test。当执行Test的main方法是会输出什么呢？ 12345678910111213141516171819202122//输出结果执行Parent静态代码块：b =2执行Child静态代码块：d =2执行Parent普通代码块： a =1执行Parent普通代码块： b =3执行Parent无参构造函数： a =2执行Parent无参构造函数： b =4执行Child代码块： c =1执行Child代码块： d =3执行Child构造函数： c =2执行Child构造函数： d =4执行Child的fun方法…………………………………………………………………………………………………………………………执行Parent普通代码块： a =1执行Parent普通代码块： b =4执行Parent无参构造函数： a =2执行Parent无参构造函数： b =5执行Child代码块： c =1执行Child代码块： d =4执行Child构造函数： c =2执行Child构造函数： d =5执行Child的fun方法 下面我们一起来看看这些输出是这么一步步产生的。 注：本文的重点不是虚拟机有关的详细执行，之后会专门写一个关于虚拟机加载的文章，所以有关细节问题都一笔带过了","tags":[{"name":"java","slug":"java","permalink":"http://anning1994.github.io/tags/java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://anning1994.github.io/tags/读书笔记/"}]},{"title":"java基础1--面向对象思想","date":"2017-04-16T08:34:32.000Z","path":"2017/04/16/java基础1--面向对象思想/","text":"解读面向对象我们常见的编程范式有命令式编程，函数式编程，逻辑式编程，面向对象编程是一种命令式编程。 命令式编程是面向计算机硬件的一种抽象，有变量（存储单元），赋值语句（获取存储指令），表达式（引用存储单元和算术运算）和控制语句（跳转指令），命令式程序就是对一个冯诺依曼机的指令序列的抽象，面向对象是对我们现实世界模型的一个抽象，之后在映射到冯诺依曼机的指令序列。 面向对象的基本特性如果只是用变量，赋值语句，表达式，控制语句去构建现实世界模型的话会非常困难，所以面向对象的出现的根本原因就是就是为了解决这个问题。 面向对象让我们从指令代码操作变量转变为通过指令操作对象。 当我们理解了这个以后再去看面向对象的基本特征： 抽象封装 首先抽象就是建立一个对现实模型的抽象，封装就是将变量，赋值语句，表达式，控制语句进行组合来描述上面的抽象，并且将他们“打包”，看成一个原子结构，之后的程序逻辑都是围绕着这个原子结构进行的。 最后，面向对象的编程就是将原来的 ”模式一“ 改变为 ”模式二” 模式一：程序 = （赋值语句+表达式+控制语句）+ 变量 模式二：程序 = 对象 + 对象（对象之间的调用） 面向对象的高级特性对象之间的关联关系抽象，封装只是对现实模型和冯诺依曼机之间基本的映射关系，而现实世界中模型与模型之间还存在很多关系，如继承、组合、依赖等。 而维护这些关系也成为面向对象语言的一个特性，并且有相应的语法支持。 1.继承is-a组合：一个类继承具有相似功能的另一个类，根据需要在所继承的类基础上进行扩展。优点： 具有共同属性和方法的类可以将共享信息抽象到父类中，增强代码复用性，同时也是多态的基础。缺点： 子类中扩展的部分对父类不可见，另外如果共性比较少的时候使用继承会增加冗余代码。 2.组合has-a组合：has-a组合是在一个类中引用另一个类作为其成员变量。优点： 可扩展性和灵活性高。在对象组合关系中应优先考虑has-a组合关系。缺点： 具有共性的类之间看不到派生关系。 多态多态在代码复用中起着尤为重要的作用，如：对象A依赖对象B；对象C继承对象B；（说明对象C包含对象B，所以当对象C向上转型为对象B时不会出现信息的丢失，大部分静态编程语言都支持向上转型。）对象A引用对象B的操作也完全适用于对象C，依赖对象B和依赖C时有不同的表现，并且这个判断过程在运行期根据真实对象所决定的。 1234567891011121314151617181920212223242526272829303132public class A &#123; public void fun(B b)&#123; b.fun(); &#125;&#125;public class B &#123; public void fun()&#123; System.out.println(\"我是b\"); &#125;&#125;public class C extends B&#123; //重载 public void fun()&#123; System.out.println(\"我是c\"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; A a = new A(); B b = new B(); C c = new C(); a.fun ( b ); a.fun ( c ); &#125;&#125;-------------------------------------------------Output:我是b我是c 以上是最简单的多态的例子，通过上面例子很难发现多态的好处，这样做的意义是什么？ 观察上面的代码会发现，A的fun( )方法参数为B，但是如果传递别的类型可不可以？答案是可以的，因为上面的代码中我们传递了B的子类C，如果有D、E、F….都继承B的话，也都可以传递到A的fun( )中，这样便起到了复用的作用。 但是还是体现不出来多态的好处，传递必须要继承这个类，不符合现实模型，比如A是播放叫声的装置，B是斑点狗，所以将B传递进去时会播放斑点狗的叫声，而C要是继承B,在现实生活世界模型中，C也是斑点狗才行。 那如果我想播放牧羊犬的叫声怎么办？用抽象类就可以。如果B是抽象类的话，抽象的是狗，所以C可以是任何狗，因为B中的所有东西都是抽象的，没有任何描述狗细节的东西，所以可以是任何狗。 最后还是发现不完善，那如果我要播放猫叫声怎么办？这时候会有个比抽象类还抽象的东西，那就是接口，一个超级有用的家伙，有了他就可以完全和现实世界模型对应起来了，因为接口抽象的是行为，所以当B为接口时，规定B有叫声方法，所以当A的fun方法中传递的B接口时，就可以理解为，只要传递实现叫声方法的就可以，无论什么。所以当猫实现这个接口后，就可以被放到声音播放器当中，同样马、猪、牛都可以，只要他们实现叫声接口就行，但是树可以吧？很显然是不可以的，因为现实世界中的树不可以叫，放到程序中即为树无法实现叫声接口，因为无法实现叫的方法。所以接口只抽象行为，完全可以实现现实模型的和面向对象的映射。 所以抽象程度从小到大分别为类&gt;抽象类&gt;接口。 当B为类时，A只能接收B子类。 当B为抽象类时，A能接收符合这个抽象的具体。 当B为接口时，A能接收实现B接口的任何东西，在当前上下文中就是有叫声的任何东西。 所以当B为普通类时，A就是一个 斑点狗叫声播放器。当B为抽象类时，A就为一个 狗的叫声播放器。而当B为接口时，A就是一个 叫声播放器，可以播放任何声音，这就是多态的意义。 一个斑点狗播放器和一个可以播放任何声音的播放器不存在那个更好，要根据实际的场景进行判断，一个作用域小一个作用域大。 其实在框架中或者“造轮子的人”用接口的比较多，而“用轮子的人”用普通类比较多，所以当阅读源码发现各种接口时不要疑惑，那多数是为了让代码更通用、作用域更大。","tags":[{"name":"java","slug":"java","permalink":"http://anning1994.github.io/tags/java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://anning1994.github.io/tags/读书笔记/"}]},{"title":"代码界的石器时代（转载）","date":"2017-03-17T09:20:00.000Z","path":"2017/03/17/代码界的石器时代/","text":"原文链接： https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn 公园漫步时间机器启动……我们来到公元前380年，也就是2000多年前的雅典城外。这是一个阳光明媚的久违的春天，柏拉图和一个帅气的小男仆走在一片橄榄树荫下。他们正准备前往一个学院。天气很好，吃得很饱，渐渐的，两人的谈话转向了哲学。 “你看那两个学生，哪一个更高一些？”，柏拉图小心的选择用字，以便让这个问题更好的引导眼前的这个小男孩。小男仆望向水池旁边的两个男生，“他们差不多一样高。”。“差不多一样高是什么意思？”柏拉图问。“嗯……从这里看来他们是一样高的，但是如果走近一点我肯定能看出差别来。”柏拉图笑了。他知道这个小孩已经朝他引导的方向走了。“这么说来你的意思是世界上没有什么东西是完全相同的咯？”思考了一会，小男孩回答：“是的。万物之间都至少有一丁点差别，哪怕我们无法分辨出来。”说到点子上了！“那你说，如果世界上没有什么东西是完全相等的，你怎么理解完全相等这个概念？”小男仆看起来很困惑。“这我就不知道了。” 这是人类第一次试图了解数学的本质。柏拉图认为我们所在的世界中，万事万物都是完美模型的一个近似。他同时意识到虽然我们不能感受到完美的模型，但这丝毫不会阻止我们了解完美模型的概念。柏拉图进而得出结论：完美的数学模型只存在于另外一个世界，而因为某种原因我们却可以通过联系着这两个世界的一个纽带来认识这些模型。一个简单的例子就是完美的圆形。没有人见过这样的一个圆，但是我们知道怎样的圆是完美的圆，而且可以用公式把它描述出来。 如此说来，什么是数学呢？为什么可以用数学法则来描述我们的这个宇宙？我们所处的这个世界中万事万物都可以用数学来描述吗？数理哲学是一门很复杂的学科。它和其他多数哲学一样，更着重于提出问题而不是给出答案。数学就像拼图一样，很多结论都是这样推导出来的：先是确立一些互不冲突的基础原理，以及一些操作这些原理的规则，然后就可以把这些原理以及规则拼凑起来形成新的更加复杂的规则或是定理了。数学家把这种方法称为“形式系统”或是“演算”。如果你想做的话，可以用形式系统描述俄罗斯方块这个游戏。而事实上，俄罗斯方块这个游戏的实现，只要它正确运行，就是一个形式系统。只不过它以一种不常见的形式表现出来罢了。 如果半人马阿尔法上有文明存在的话，那里的生物可能无法解读我们的俄罗斯方块形式系统甚至是简单的圆形的形式系统，因为它们感知世界的唯一器官可能只有鼻子，也许它们是无法得知俄罗斯方块的形式系统了，但是它们很有可能知道圆形。它们的圆形我们可能没法解读，因为我们的鼻子没有它们那么灵敏，可是只要越过形式系统的表示方式（比如通过使用“超级鼻子”之类的工具来感知这些用味道表示的形式系统，然后使用标准的解码技术把它们翻译成人类能理解的语言），那么任何有足够智力的文明都可以理解这些形式系统的本质。有意思的是，哪怕宇宙中完全不存在任何文明，类似俄罗斯方块还有圆形这样的形式系统依旧是成立的：只不过没有智慧生物去发现它们而已。这个时候如果忽然一个文明诞生了，那么这些具有智慧的生物就很有可能发现各种各样的形式系统，并且用它们发现的系统去描述各种宇宙法则。不过它们可能不会发现俄罗斯方块这样的形式系统，因为在它们的世界里没有俄罗斯方块这种东西嘛。有很多像俄罗斯方块这样的形式系统是与客观世界无关的，比如说自然数，很难说所有的自然数都与客观世界有关，随便举一个超级大的数，这个数可能就和世界上任何事物无关，因为这个世界可能不是无穷大的。 历史回眸再次启动时间机……这次到达的是20世纪30年代，离今天近了很多。无论新旧大陆，经济大萧条都造成了巨大的破坏。社会各阶层几乎每一个家庭都深受其害。只有极其少数的几个地方能让人们免于遭受穷困之苦。几乎没有人能够幸运的在这些避难所里度过危机，注意，我说的是几乎没有，还真的有这么些幸运儿，比如说当时普林斯顿大学的数学家们。 新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。 一个名叫阿隆佐·邱奇(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有艾伦·图灵、约翰·冯·诺伊曼、库尔特·哥德尔。这四个人都对形式系统感兴趣。相对于现实世界，他们更关心如何解决抽象的数学问题。而他们的问题都有这么一个共同点：都在尝试解答关于计算的问题。诸如：如果有一台拥有无穷计算能力的超级机器，可以用来解决什么问题？它可以自动的解决这些问题吗？是不是还是有些问题解决不了，如果有的话，是为什么？如果这样的机器采用不同的设计，它们的计算能力相同吗？在与这些人的合作下，阿隆佐设计了一个名为lambda演算的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。这种函数用希腊字母lambda（λ），这种系统因此得名4。有了这种形式系统，阿隆佐终于可以分析前面的那些问题并且能够给出答案了。除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。 如果二战没有发生，这个故事到这里就应该结束了，我的这篇小文没什么好说的了，你们也可以去看看有什么其他好看的文章。可是二战还是爆发了，整个世界陷于火海之中。那时的美军空前的大量使用炮兵。为了提高轰炸的精度，军方聘请了大批数学家夜以继日的求解各种差分方程用于计算各种火炮发射数据表。后来他们发现单纯手工计算这些方程太耗时了，为了解决这个问题，各种各样的计算设备应运而生。IBM制造的Mark一号就是用来计算这些发射数据表的第一台机器。Mark一号重5吨，由75万个零部件构成，每一秒可以完成3次运算。战后，人们为提高计算能力而做出的努力并没有停止。1949年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是冯·诺伊曼设计架构的第一个实例，也是一台现实世界中实现的图灵机。相比他的这些同事，那个时候阿隆佐的运气就没那么好了。到了50年代末，一个叫John McCarthy的MIT教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！很多计算机科学家都认识到了Lisp强大的能力。1973年在MIT人工智能实验室的一些程序员研发出一种机器，并把它叫做Lisp机。于是阿隆佐的lambda演算也有自己的硬件实现了！","tags":[{"name":"宏观编程","slug":"宏观编程","permalink":"http://anning1994.github.io/tags/宏观编程/"}]},{"title":"Apache VFS","date":"2017-03-16T14:20:02.000Z","path":"2017/03/16/Apache-VFS/","text":"Apache VFS简要介绍VFS （虚拟文件系统），可以通过程序 去操作文件系统，这里说的文件系统是一个泛称，不同的文件系统有着不同的操作权限，它具体包括下表的几种文件系统（红色标记的是我们之后可能会用到的文件系统）: Name Authentication Read Write Create/Delete Random Version Rename FILE NO Yes Yes Yes Read/Write NO Yes FTP Yes Yes Yes Yes Read NO Yes HTTP Yes Yes NO NO Read NO NO BZIP2 NO Yes Yes NO NO NO NO FTPS Yes Yes Yes Yes Read NO Yes GZIP NO Yes Yes NO NO NO NO HDFS NO Yes NO NO Read NO NO HTTPS Yes Yes NO NO Read NO NO Jar NO Yes NO NO NO NO NO RAM NO Yes Yes Yes Read/Write NO Yes RES NO Yes Yes Yes Read/Write NO Yes SFTP Yes Yes Yes Yes Read NO Yes Tar NO Yes NO NO NO NO NO Temp NO Yes Yes Yes Read/Write NO Yes WebDAV Yes Yes Yes Yes Read/Write Yes Yes Zip NO Yes NO NO NO NO NO VFS使得各种不同的文件系统使用一个API。例如本地磁盘上的文件，HTTP服务器上的文件或Zip存档内的文件。 开始使用依赖1234567&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-vfs2 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-vfs2&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; 核心API1.FileSystemManager管理文件系统的接口，是最上层的接口，必须先得到FileSystemManager，可以获得具体的FileObjectFileObject在下面会有介绍。获取FileSystemManager最常用的方式就是：12FileSystemManager fsm = VFS.getManager(); 2.FileObject它代表一个文件，和Java File不同，它具有更多延伸的功能和信息。实现FileObject接口的文件对象有很多大部分FileObject实现类都继承AbstractFileObject类,如下是常用的实现类: LocalFile FtpFileObject HttpFileObject SftpFileObject ZipFileObject TarFileObject RamFileObject UrlFileObject 12345 /** * @param path * @return */FileObject fileobject = fsm.resolveFile(path); path是文件的路径，不同的文件系统有不同的前缀 File [file://] absolute-path Examples: file:///home/someuser/somedirfile:///C:/Documents and Settingsfile://///somehost/someshare/afile.txt/home/someuser/somedirc:\\program files\\some dirc:/program files/some dir Ftp ftp://[ username[: password]@] hostname[: port][ relative-path] Examples: ftp://lxsoft:123456@127.0.0.1/pub/downloads/somefile.tgz Http http://[ username[: password]@] hostname[: port][ absolute-path] Examples: http://127.0.0.1:8080/downloads/somefile.jarhttp://username@127.0.0.1/index.html FileObject表示一个具体文件，文件有两种类型： 目录 普通文件 普通文件拥有数据或者说内容。而目录不含有内容，只能包含其他文件。 FileObject提供大量的方法，足以满足读取，删除，复制，重命名等基本操作。 FileObject接口的API 高级特性及demo文件的监听FileListener 有两个实现类DelegateFileObject和WeakRefFileListener，时间有限没有研究这两个实现类是干什么的，有兴趣的同学可以研究一下，但是这个监听类是可以绑定到文件系统上面的。 12345678910111213141516171819202122232425262728293031FileSystemManager fsm = VFS.getManager();FileObject fileObject = fsm.resolveFile(path);//在文件系统中添加监听器（lambda和匿名内部类都会方便点，也可以直接new个对象传到addListener方法中）fileObject.getFileSystem().addListener(fileObject,new FileListener() &#123; @Override public void fileCreated(FileChangeEvent fileChangeEvent) throws Exception &#123; String name = fileChangeEvent.getFile().getName().getBaseName(); System.out.print(\"文件创建了\"+name); &#125; @Override public void fileDeleted(FileChangeEvent fileChangeEvent) throws Exception &#123; String name = fileChangeEvent.getFile().getName().getBaseName(); System.out.print(\"文件删除了\"+name); &#125; @Override public void fileChanged(FileChangeEvent fileChangeEvent) throws Exception &#123; String name = fileChangeEvent.getFile().getName().getBaseName(); System.out.print(\"文件更改了\"+name); &#125; &#125;); if (fileObject.exists())&#123; //删除path对应的文件或者目录 //fileObject.delete() &#125;else&#123; //创建一个文件 fileObject.createFile(); //或者创建文件夹 //fileObject.createFolder() &#125; 文件过滤通过看API试出来的方法，这方面网上的资料太少了，只有以后遇到什么需求在查看API去解决。123456789101112131415161718192021FileSystemManager fsm = VFS.getManager();FileObject fileObject = fsm.resolveFile(path);//lambda表达式更加直观方便FileSelector selector = new FileFilterSelector((fileSelectInfo)-&gt;&#123; boolean isCSV = fileSelectInfo.getFile().getName().getBaseName().endsWith(\".txt\"); return isCSV; &#125;);//匿名内部类，效果等同于上面的lambda// FileSelector selector = new FileFilterSelector(new FileFilter() &#123;// @Override// public boolean accept(FileSelectInfo fileSelectInfo) &#123;// boolean isCSV = fileSelectInfo.getFile().getName().getBaseName().endsWith(\".txt\");// return isCSV;// &#125;// &#125;); FileObject[] findFiles = fileObject.findFiles(selector); for (int i = 0; i &lt; findFiles.length; i++) &#123; String name = findFiles[i].getName().getBaseName(); System.out.print(name); &#125; &#125; 这段代码的作用就是过滤出在path下*.txt的所有文件","tags":[{"name":"编程规范","slug":"编程规范","permalink":"http://anning1994.github.io/tags/编程规范/"}]},{"title":"关于写博客的一点小想法","date":"2017-03-15T14:04:04.000Z","path":"2017/03/15/关于写博客的一点小想法/","text":"千里之行，始于足下越来越发现，一件复杂的事情只要满足两个条件就可以做好，一是坚持不懈、二是有个开始。 很早以前就有写博客的想法，直到现在才正式动笔，中间很长一段时间都是在想这件事是如何的复杂，如何困难。直到意识到工作中遇到的很难的事，也都通过一点一点的努力完成了。回头想想，自己之前认为困难的事，其实难都难在不去开始。这些新的思想觉悟便是自己搭建这个博客的主要驱动力。 思所以危则安矣避免技术更新导致自我价值降低很重要。 软件研发技术迭代很快，是一个 表面 上没有技术积累的行业。所以思维方式，学习方法，核心概念的理解，远远比那些机械的记忆程序的配置，单纯的参考网上的例子实现功能要重要的多。如果仅仅是代码的搬运工，极可能被技术更新的大浪所埋没。所以，透彻的理解技术映射出的本质，拥有这样的思想是每一个“优质码农”都应该具备的，看过很多阿里的技术沙龙，每一个主讲人的特点都是去解释思想，本质。而那些技术的用法都是一概而过。抛开技术而言，这些人在分享过程中也是很有特点的： 条理清晰 思维缜密 谦逊客观技术横纵双向发展善于分析新旧技术的核心区别 这些天赋异禀的人的特点，看起来就像”成功的**所必备的n个**”的俗鸡汤，但是这些特点确实是很值得去借鉴和培养的。 厚积而薄发其实自己搭建博客主要是因为可以装逼自主方便，其目的是整理一些印象笔记里平时记录的东西。 一方面秉承互联网大环境分享精神的大统，另一方面可以在写的过程中可以系统的完善自己的知识体系。在学习新知识的同时也要时不时的回头去沉淀一下自己的旧知识。 我相信收获一定会有的，一直往前走，它会突然出现在未来的某一天，共勉。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://anning1994.github.io/tags/随笔/"}]}]